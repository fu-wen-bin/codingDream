# 必要知识回顾

## `v8`是如何存储数据的

- 栈内存：
    - 存储函数调用的上下文信息
    - 存储局部变量和参数
    - 存储函数执行时的状态
    - 栈内存的大小是固定的
- 堆内存：
    - 存储对象和数组等复杂数据结构
    - 存储动态分配的内存
    - 堆内存的大小可以动态调整

## `js`中的数据类型

- 简单类型
- 复杂类型

# 拷贝

- 复刻一个对象，和原数组长得一模一样

## 浅拷贝

1. `Object.create(obj)`

    - 创建一个新对象，对象原型指向源对象
    - 继承自原对象的原型
    - 不会拷贝原对象的属性值

2. `[].concat(obj)`

    - 创建一个新数组
    - 包含原数组的所有元素
    - 不会拷贝原数组的引用类型元素

3. 数组解构

    - 使用扩展运算符 `...`
    - 创建一个新数组
    - 包含原数组的所有元素
    - 不会拷贝原数组的引用类型元素

4. `arr.slice()`

    - 创建一个新数组
    - 包含原数组的所有元素
    - 不会拷贝原数组的引用类型元素

5. `Object.assign({}, obj)`

    - 创建一个新对象
    - 拷贝原对象的所有可枚举属性
    - 不会拷贝原对象的不可枚举属性和原型链上的属性

6. `arr.toReversed.reverse()`

    - 创建一个新数组
    - 包含原数组的所有元素
    - 不会拷贝原数组的引用类型元素

## 深拷贝：层层拷贝，新对象和源对象互相独立互不影响

1. `JSON.parse(JSON.stringify(obj))`

    - 将对象转换为`JSON`字符串
    - 再将`JSON`字符串解析为对象
    - 无法处理`function`、`undefined`、`Symbol`、`BigInt` 等不可序列化的类型
    - **无法处理循环引用**

2. `structuredClone(obj)`

    - 使用**浏览器内置**的 `structuredClone` 方法
    - 可以处理复杂数据结构和循环引用
    - 需要浏览器支持
    - 仍然无法处理`function`

3. 使用递归函数

    - 手动实现深拷贝
    - 需要处理循环引用和特殊类型
    - 可以使用 `WeakMap` 来**解决循环引用**问题

4. 使用第三方库

    - 如`Lodash`的 `_.cloneDeep()`
    - **可以处理复杂数据结构和循环引用**
