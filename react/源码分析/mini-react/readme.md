# 分析

1. jsx -->  render function -->  virtual dom （vdom）

2. 在 vdom 中，父子节点的关系是通过 children 来表示的，为了让父子节点关联更密切，查找更高效，react 将 vdom 进而处理成 fiber
   结构（链表），于是在节点处理时，可以高并发

3. 18 版本之前是基于 React Element 递归渲染，计算量过多就容易导致页面卡顿，
   18 版本之后，基于 fiber 架构，将递归渲染改成了基于 fiber 链表的迭代渲染，计算量减少，渲染效率提高。
   主要因为链表是可以被打断的，处理到某一个节点时可以停下来处理其他的节点。

# fiber

处理某一个节点时，如果发现一段时间之后还没处理完，就会把当前的节点的状态保存下来，然后处理其他的节点，等其他节点处理完了，再回来处理当前的节点 ----
时间分片机制

- 通过记录 parent， child， sibling 信息，让树变成链表，于是就可以被打断，每次处理一个 fiber 节点，处理每一个 fiber
  节点前判断是否带了固定的时间间隔，通过这种时间分片的手段将 处理 fiber 的过程放到多个任务里面执行，大大较少了页面内容过多的卡顿问题。

# diff

react中的 diff算法是用来比较 fiber 节点的差异的，从而确定哪些节点需要更新，哪些节点不需要更新，从而减少更新的次数，提高渲染效率。

# 总结

1. render 阶段：把 jsx --> vdom --> fiber 链表
2. commit 阶段：把 fiber 链表渲染到页面上

# MiniReact

1. 借助 tsc 编译 jsx
2. 配置 tsconfig.json 设置 tsc 在编译 jsx时启用 MiniReact.createElement
3. 得到了 vdom 树，将 vdom 树转换为 fiber 链表
4. 递归遍历 fiber 链表，根据节点的特性来生成对应的 dom

# diff

- diff 是 react中一个用来比较 fiber 节点的差异的算法，只会比较同层的节点，不会跨层比较。

1. 判断新老节点类型是否相同，如果类型相同，复用老节点的 dom 结合新节点的 props 属性
2. 如果类型不同，且存在新节点，用新的节点直接替换
3. 如果类型不同，且不存在新节点，删除老节点
4. 否则，直接启用老节点