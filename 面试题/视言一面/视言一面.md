# 视言一面

## 自我介绍 -- [参考](https://juejin.cn/post/7335337310547017768)

## 低代码平台

### 介绍一下这个项目

1. 为什么要写这个项目
2. 项目结构梳理（仓库结构，一个仓库存放整个项目的完整json对象，一个仓库存放每一类组件的配置文件）
3. 画布区域通过`React.createElement`将`json`对象递归渲染成对应组件
4. 使用dnd封装一个拖拽钩子，指明哪个组件被拖拽，哪个地方可以接收被拖拽的组件
5. 选中画布上的组件，右侧可以配置组件的属性、样式和事件，通过styles-to-object将配置的内容转换成对象，更新到json对象中进行渲染
6. 项目需要编辑模式和预览模式，预览模式也是通过递归渲染的页面。不一样的是编辑模式下，组件上的事件是不会被触发的

### tailwind相比于传统写CSS文件有什么区别

1. 开发效率高，不需要创建多个CSS文件，减少切换文件时间
2. 不用担心命名问题，不用考虑样式冲突的问题
3. 更小的CSS体积
4. 维护性高，类名都是语义化

### 组件拖拽当中遇到的层级覆盖问题

1. 在选择并拖拽组件时，将被选中的组件的`z-index`设置为最高
2. 在释放组件时，将该组件的`z-index`设置为初始值或者`auto`

### react18和react19的区别

1. React19中新增了`useTransition`这个钩子，比如在form表单提交时，不需要再人为处理loading状态
2. 新增`useActionState`来处理表单提交的常见的状态变更
3. 可以将`ref`作为`props`进行传递
4. 对`html`标签的支持更完善
5. 移除了不需要的`API`和压缩代码，`React19`的体积比`React18`更小

### webpack 和 vite 的区别

1. vite是基于es模块化的，webpack是基于打包构建的
2. vite的热更新更快，webpack是基于文件监听的
3. vite的配置更简单，webpack需要配置很多loader和plugin

## CSS

1. 垂直水平居中的方式

    - flex布局，将父级元素设置为flex弹性盒子，再设置align-item和justify-content为center
    - gird布局，将父级元素设置为grid网格布局，再设置align-item和justify-content为center
    - 绝对定位，将父元素设置为relative，子元素使用absolute定位，通过top、left设置为50%，由于定位是根据元素左上角，还需要使用transform
      translate(-50%, -50%)进行自身宽度和高度一半的偏移量
    - 列表布局，将父元素设置为table，子元素为table-cell，再设置vertical-align为middle，text-align为center

2. CSS的选择器以及它们的优先级，优先级最高的为

    - ID选择器
    - 属性、类、伪类选择器
    - 元素、伪元素选择器
    - 通配符选择器
    - 子代、后代、兄弟选择器

3. `rem`和`em`的区别

    - `rem`是根据浏览器根字体大小进行计算
    - `em`是根据父级元素的字体大小进行计算的
    - 两个都可以用来做响应式布局

4. 场景题（margin 塌陷问题）

    - margin塌陷问题一般是由于元素在垂直方向上的`margin`重叠导致
    - 可以使用BFC解决
        - BFC触发条件
            1. `overflow`属性不为`visible`
            2. `position`属性为`absolute`或`fixed`
            3. `display`属性为`inline-xxx`、`flex`、`grid`、`table-xxx`
            4. `float`属性不为`none`

## JS

1. JS中的数据类型以及类型判断

    - 基本数据类型：`number`、`string`、`boolean`、`null`、`undefined`、`symbol`、`bigint`
    - 引用数据类型：`object`（数组、函数、对象、正则等）
    - 类型判断
        - `typeof`
        - `instanceof`
        - `Object.prototype.toString.call()`
        - `Array.isArray()`
        - `null`的判断只能使用全等判断
        - `NaN`的判断只能使用`Number.isNaN()`，因为`NaN === NaN`返回false

2. 如何阻止事件冒泡，不使用监听器如何阻止事件冒泡

    - js中存在事件流，在事件逐步往里进行的过程叫捕获，从目标标签往外进行的过程叫冒泡
    - 事件触发顺序：捕获阶段 -->目标阶段 --> 冒泡阶段
    - 一般事件会在冒泡阶段触发
    - 通过`event.stopPropagation()`阻止事件冒泡
    - 通过`event.stopImmediatePropagation()`阻止事件冒泡，并且阻止当前元素上后续事件的触发
    - 不使用监听器，通过自己写一个`onclick`事件函数传入事件参数直接触发，再使用event.stopPropagation()阻止冒泡

3. 场景题：

    - 一个函数的形参为一个数组，返回的一个新的数组，内容是原数组内容的Clone

        - 使用`map`方法
        - 使用`for`循环

    - 数组去重
   
        - 使用`Set`数据结构 -- `Set`中数据是唯一的，但是`Set`是伪数组
        - 使用`for`循环结合`indexOf` -- 一个个放进新数组，如果新数组中没有就放进去

4. 浏览器事件循环

5. 根据代码看输出结果 -- 定时器都是共享时间，按照时间到期先后顺序执行，遇到同步代码会先执行同步代码

   ```JS 
   setTimeout(() => {
     console.log(1);
   }, 20);
   
   console.log(2);
   
   setTimeout(() => {
     console.log(3);
   }, 10);
   
   console.log(4);
   
   for (let i = 0; i < 9000; i++) {
     // do soming 80ms左右
   }
   
   console.log(5);
   
   setTimeout(() => {
     console.log(6);
   }, 8);
   
   console.log(7);
   
   setTimeout(() => {
     console.log(8);
   }, 15);
   
   console.log(9);
   ```

6. Promise, async await的区别

    - Promise是一个对象，代表一个异步操作的最终完成（或失败）及其结果值
    - async await是基于Promise的语法糖，可以让异步代码看起来像同步代码，更加直观和易读
    - Promise使用`then`方法进行链式调用，async await使用`await`关键字等待Promise的结果

7. Promise, async await 的错误捕获机制

    - Promise使用`catch`方法捕获错误
    - async await需要使用原生js中的try catch进行捕获错误

## React

1. 类组件和函数组件的区别
2. 介绍`useEffect`钩子
3. 怎么样让`useState`的执行变成同步
4. react16和react18的区别，它们的diff算法的区别

## 其它

1. 你使用coze工作流的详细介绍
2. 为什么选择前端，平时专门学习的
3. 有看过什么技术类的书

## 算法

1. 回文字符串