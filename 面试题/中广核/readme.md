# 块级元素、行内元素、行内块元素的区别？分别举几个例子，如何改变？

- 块级元素：可以定义宽高，独占一整行（`<div>`、`<p>`标签）
- 行内元素：占据内容的宽高，不占一行，不可自定义（`<span>`、`<a>`、`::before`、`::after`等）
- 行内块元素：不占一整行，可以定义宽高（`<img>`、`<button>`等）
- 使用`display: inline-block`实现转化

# 有用过语义化的html标签吗？

答：基本只用了`main`作为主题内容的标签。

面试官：一般用在定义页面结构，有利于代码的`review`和`SEO`

# 我想在标签中修改样式，有几种方式实现？选择器和他们的优先级

答：内联样式、css选择器修改

1. css选择器类型（按优先级排序）

- ID选择器：选择指定ID的选择器
- 属性、类、伪类选择器
- 元素、伪元素选择器
- 通配符选择器
- 子代、后代、相邻兄弟、通用兄弟选择器

# 说一说盒子模型，怎么切换？

盒模型分为标准盒模型和怪异盒模型。

- 标准盒模型定义的宽高只会作用在内容区
- 怪异盒模型定义的宽高会包括内容、内边距、边框
- 使用`box-sizing: border-box`切换，不使用就是默认标准盒模型

# 有使用flex、gird进行布局吗？说一说

- 大部分使用的弹性布局，弹性容器有主轴交叉轴之分，默认主轴是水平，交叉轴是垂直
- 弹性容器的子元素默认沿着主轴排列
- 子容器可以设置order属性，值越小排序越靠前
- 子容器默认不放大，但可以设置`flex-grow: 1`允许子元素放大
- 子容器默认可以缩小，可以设置`flex-shrink:0`阻止子元素缩小

flex: 0 0 200px;

# 怎么将元素水平垂直居中？

- 使用`flexbox`，`align-item`和`justify-content`设置为`center`
- 使用定位布局：父元素设置**相对定位**，子元素设置**绝对定位**，将子元素上面和左边的距离设置为`50%`，由于位置是根据元素左上角进行设置，所以需要使用
  `transform`将位置再移动回元素的一半高度
- 使用`grid`，`align-item`和`justify-content`设置为`center`
- 使用表格布局，让元素成为行内块元素，并设置`vertical-align: middle` 和`text-align: center`

# BFC 了解吗，怎么触发？

BFC是块级格式化上下文，拥有一个独立的渲染区域。在不使用时，元素如果都有margin属性，可能会导致重叠，发生margin坍塌。使用BFC则不会导致

触发方式有：

- `float`不为`none`的条件下都可以触发
- `display`为`inline-xxx`、`flex`、`table-xxx`、`gird`
- `overflow`不为`visible`的条件下都可以触发
- `position`为`absolute`、`fixed`

# 了解回流重绘和重排吗？

啊吧啊吧啊吧啊吧啊吧

# 说一说定位

- 绝对定位：根据上一个有定位属性的父级元素进行定位
- 相对定位：根据元素原本的文档流进行定位
- 固定定位：根据浏览器视窗机型定位
- 粘性定位：行为有点像`relative`，滚动越过对应位置时，会像`fixed`
- 静态定位：静态定位就是元素按照正常文档流进行定位

# z-index层级消失

完全没答上来，只回答了脱离了文档流，面试官也没有后续解释直接下一题了

# 遇到过防抖节流的情况吗？

遇到过，就在我这个项目中，在用户输入数据的时候，服务器定义的是每次修改都会进行保存。但是这样比较开销性能，也没有必要。所以使用了防抖将几次的输入合并后再进行保存
**（以后这一块可以直接展开解说，防抖的原理和实现）**

# JS类型有哪些，有哪些数据类型？

- 简单数据类型
    1. string
    2. number
    3. boolean
    4. undefined
    5. bigint
    6. null
- 复杂数据类型
    1. object
    2. function
    3. Date

# Null和undefined的区别？

答案：

- undefined 通常表示一个没有初始化的变量或者函数参数的缺失
- null 是一个关键字，用于表示一个空的对象引用，表示当前变量或者对象没有任何值。需要显式地将变量赋值为 *null*
- 类型转换：
    - 在布尔上下文中，*undefined* 和 *null* 都被当作 *false*
    - 在数值上下文中，*undefined* 转换为 *NaN*，而 *null* 转换为 *0*
    - 在字符串上下文中，*undefined* 转换为 *"undefined"*，而 *null* 转换为 *"null"*
- typeOf 判断类型
    - undefined 会被判定为undefined
    - null 会被判定为object

# 双等于号和三等于号的区别？

双等于号也叫**宽松相等**，会存在隐式类型转换，三等于号不存在转换

# let、var、const声明变量时有什么区别？

- let 变量不存在声明提升，var存在
- let变量可以重新赋值，const不可以
- let和{ }会形成一个块级作用域
- let 不允许重复声明同一个变量名，var 可以
- var 在全局声明的变量，会成为 window 的属性， let 不会

# 同步和异步

1. 同步任务：在主线程中执行的任务
2. 异步任务：在主线程外执行的任务，执行完后会将回调函数放入消息队列中

同步和异步来源其实是js默认是单线程，为了执行效率和尽量减少用户设备的性能开销，将耗时任务（不是我们认知意义上的耗时代码）分为异步代码。在js执行代码的过程中碰到异步代码会阻塞主进程的渲染所以有事件循环进行解决。

- 事件循环：
    1. 先执行同步代码，也叫宏任务
    2. 执行完宏任务后检查微任务队列，依次执行微任务
    3. 微任务队列清空后，有需要的情况下渲染页面
    4. 渲染完成后，再执行同步任务。一次循环

# # 浏览器存储有几种方式

1. cookies -- 存储少量数据，随着请求发送存在过期时间
    - cookies一般需要后端靠响应代码进行存入
    - 可以设置过期时间，如果不设置过期时间，默认是会话级别，浏览器关闭后就会消失
    - cookie可以跨域
2. localStorage -- 大小比cookie稍微大一些，不可以设置过期时间默认永久存在
    - 需要使用js进行操作
    - 不可以跨域
3. sessionStorage -- 理论上无穷大，页面关闭就过期
    - 需要js进行操作
    - 不可以跨域
4. indexdb -- 纯客户端本地的数据库，理论上是无穷大的，不可以设置过期时间
    - 需要js进行操作，支持存储二进制数据
    - 不可以跨域
    - 可以存储大量数据，可以支持离线访问

# 常见的http方法

- GET (参数在url 后面， get 请求会被浏览器缓存)
- POST （参数在请求体中， post 支持更多的编码方式）
- OPTIONS
- DELETE

# 项目里使用了Token，说说你的Token是怎么实现的，发请求的时候放在哪？

这个很简单很基础了随便答就好，顺便拓展无感刷新

# 图片上传怎么实现？

一开始他表述的特别难懂，后面我说是不是文档中的上传他说是

我说因为没有服务器，所以我是直接使用的图片转成base64的格式进行的前端预览

# 反问环节

我问的是，对于中核和中广核这种比较传统的工业公司，AI发展这么迅猛会不会造成什么冲击？

在我的认知里面，这种类似的公司对于前端的需求可能没有那么高，前端这个部门工作内容是什么？

在AI的冲击下，有什么样的发展前景？

#  















