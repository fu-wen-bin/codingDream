面试官的问题主要围绕候选人项目经历、技术实现细节及基础知识点展开，具体如下：

# 项目相关：

## 介绍项目中扣子工作流的具体步骤，从上传图片到前端收到搭配建议的环节

## 前端与后端工作流服务的集成方式

## AI任务进度的展示方式及状态实时更新手段（轮询还是其他）

## 流程中易出错的环节及前后端的错误处理、保护措施，包括错误时视图变化和重试机制

## 大图片上传的操作方式及压缩实现逻辑，是否考虑过文件分片上传

1. 图片压缩：根据canvas这个标签的特性进行压缩，将图片绘制在画布上，再将画布指定质量并导出成新的图片

## 选择本地部署模型而非调用云端API的原因

1. 隐私安全：数据都保存在本地，不会被上传到别人的服务器
2. 性能优化：本地部署可以根据用户硬件进行优化，提升响应速度
3. 成本控制：避免频繁调用云端API产生的费用

# 支持多轮对话记忆功能的实现方式，及后端对对话的存储和上下文管理方式

1. 多轮对话问题：将每轮对话的上下文存储起来，下一轮对话时将上一轮的上下文进行输入
    - token消耗量会越来越大，历史数据会越来越多
2. 上下文管理：
    - 滑动窗口：只保留最近几轮的对话，超出部分丢弃（剪枝）
    - 关键记忆读取：利用另一个LLM总结之前冗长的对话内容，提取关键信息，作为新的上下文输入
    - 向量化记忆：将历史对话转换成向量表示并存入数据库，用户每次提问，先去向量数据库中检索相关的历史对话，再将这些对话作为上下文输入
3. 对话的存储：
    - 存储在数据库中（历史对话）
    - 存储在缓存中 Redis（后端的缓存，用于存储活跃的对话）
4. 会话管理：
    - 每个用户创建一个新的会话的时候会创建一个会话ID，用来标识这一个对话
    - 前端将会话ID传递给后端，后端根据会话ID去缓存或者数据库中查找对应的对话内容
    - 会话过期时间：设置会话的过期时间，超过时间未活动则清除会话数据

# 技术安全与功能相关：

## Markdown格式可能带来的安全性问题（如XSS攻击）及预防方法

### XSS (跨站脚本攻击 -- Cross-Site Scripting)

- 同源策略无法极致地约束浏览器的行为，页面上默认允许引入第三方资源，又引入CSP策略来限制ajax请求

1. 窃取cookies信息，传输给黑客服务器，黑客就可以在其他电脑上登录用户的账号进行转账
2. 监听用户行为，比如监听用户键盘事件，窃取密码
3. 伪造登录窗口，欺骗用户输入账号密码
4. 篡改页面内容，比如修改页面标题，添加广告

- 恶意脚本是如何被注入到电脑上的？
    1. 存储型XSS攻击：脚本存入服务器 (后端接收到前端传递的数据，进行转码操作。例如：将`<`转义为`&lt;`，`>`转义为`&gt;`
       ，防止浏览器解析成标签)
    2. 反射型XSS攻击：恶意链接后凭借的参数是一个恶意脚本，点击链接后脚本给到服务端再返回给前端 (
       利用CSP策略，限制页面上可以执行的脚本来源)
    3. DOM型XSS攻击：接触用户传输的信号，修改DOM结构，导致页面发生变化(
       后端给一些比较重要的`cookie`数据设置`HttpOnly`属性，防止js脚本获取cookie)

### CSRF (跨站请求伪造 -- Cross-Site Request Forgery)

1. 自动发起 get | post 请求
2. 利用用户登录状态，发起恶意请求

## 和AI对话过程中是否支持中断功能

1. 前端向后端发送一个终止请求
2. 后端收到请求后，会立即停止当前的任务，返回一个错误信息

# 低代码编辑器相关：

## 给每个组件设置DEV和PRO两个版本的原因

1. DEV版本：提供给用户拖拽和配置属性使用，包含组件的编辑功能
2. PRO版本：提供给用户预览和使用组件，去掉了编辑功能

## 用createElement实现从层级数据到组件渲染的介绍，及频繁更新单个组件属性时如何避免整个组件重新渲染

1. `memo` 或者 `useMemo` 进行组件的缓存

# React相关钩子函数：

## React中useMemo、useState、useEffect的区别

1. useMemo：用于缓存接收到函数体的计算结果，避免重复计算
2. useState：用于在函数组件中缓存和添加状态，可以接收一个函数体
3. useEffect：可以接收一个函数体，在组件渲染后执行副作用操作。return的函数会在组件卸载后执行

## 解释闭包陷阱及让相关代码正常运行的修改方式

1. 闭包陷阱：在循环中创建函数时，函数内部引用了循环变量，导致所有函数引用的都是同一个变量，最终结果都是循环结束时的值
    - 解决方法：
        - 使用`let`声明循环变量，`let`有块级作用域，每次循环都会创建一个新的变量
        - 使用立即执行函数表达式(`IIFE`)，将循环变量作为参数传递给函数，创建一个新的作用域
2. `useEffect`的闭包陷阱：引用了组件的状态或者属性，导致每次渲染时都会创建一个新的函数，无法正确引用最新的状态或者属性
    - 解决方法：
        - 将状态或者属性添加到依赖数组中，确保每次状态或者属性变化时，`useEffect`都会重新执行
        - 使用`useRef`来存储最新的状态或者属性，每次变化的时候都在`useEffect`中更新`Ref`指向，避免闭包陷阱

# 移动端适配相关：

## 项目中封装的移动端适配库的实现方式，及REM、EM、VW的区别，做移动端时是否遇到过边框1px等适配问题

# JavaScript基础：
 
## 关于this指向问题的代码输出结果及原因，严格模式下相关代码的输出结果

1. 独立调用：`this`指向`undefined`（严格模式）或者`window`（非严格模式）
2. 对象方法调用：`this`指向调用该方法的对象
3. 构造函数调用：`this`指向新创建的对象
4. `call`、`apply`、`bind`调用：`this`指向传入的第一个参数
5. 箭头函数：`this`指向定义时的上下文环境

## 用Promise实现红黄绿灯不断循环切换的功能

# HTML相关：

## A标签target属性的取值有哪些

1. `_self`：在**当前窗口**打开链接（默认值）
2. `_blank`：在**新窗口或新标签页**打开链接
3. `_parent`：在**父框架**中打开链接
4. `_top`：在**整个窗口**中打开链接，覆盖所有框架

## doctype的作用