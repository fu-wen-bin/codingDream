# 一、JS数组上常用的的方法有哪些？

* 增：`push()`, `unshift()`, `concat()`, `splice()`
* 删：`shift()`, `pop()`, `slice()`, `splice()`
* 改：`splice()`
* 查：`includes()`, `indexOf()`, `find()`, `findIndex()`, `lastIndexOf()`, `findLastIndex()`
* 遍历：`forEach()`, `map()`, `filter()`, `every()`, `some()`, `sort()`, `reduce()`

# 二、如何实现数组扁平化？flat方法？

- 是什么

flat是Array原型上的函数，用于将高维数组处理成低维数组

- 原理

1. 递归
2. reduce + 递归
3. while + 解构
4. toString()

# 三、字符串上常用的方法有哪些？

- 增：`concat()`
- 删：`slice()`, `substring()`, `substr()`
- 改：`replace()`, `toUpperCase()`, `toLowerCase()`, `trim()`,
  `trimStart()`, `trimEnd()`, `repeat()`, `padEnd()`, `padStart()`
- 查：`includes()`, `indexOf()`, `lastIndexOf()`, `charAt()`, `startWith()`, `endWith()`, `match()`

# 四、谈谈js 中的类型转换机制

- 是什么
  js 引擎在执行各种运算符对于数据的类型是有要求的，如何数据类型和预期的不符合，就会发生类型转换

- 特点：

1. 显示类型转换
2. 隐式类型转化

- 显示类型转换：人为借助构造函数来将一种类型转换成希望的类型，这其中如果是原始值转原始值，官方给出了直接的转换结果。但如果是引用类型转原始类型：Number([1, 2])

1. ToNumber([1, 2])  || ToString()
2. ToPrimitive([1, 2], Number)
3. 判断 参数 是否为原始类型，是则返回
4. 否则，调用 xxx.valueOf()，得到原始值则返回
5. 否则，调用 xxx.toString()，得到原始值则返回
6. 否则报错

   <!-- String([1, 2]) -->

- 隐式类型转化：通常发生在 四则运算（+ - * / %），比较运算（== != > < ）判断语句（if while）

# 五、介绍一下 js 中的拷贝问题

- 是什么

  因为js 中的原始类型存在栈中，引用类型存在堆中，再把引用地址存在栈中。所以拷贝通常只发生在引用类型上。效果是创建一份新的数据，让新数据拥有原数据一样的属性值

- 方法

1. 浅拷贝：拷贝对象的属性，值如果是引用类型，则共用同一个地址
2. 深拷贝：拷贝对象的属性，值如果是引用类型，则创建新的子对象来进行新的拷贝，实现层层拷贝

- 浅拷贝:
  slice(),
  [].concat(arr),
  [...arr], Object.create()
  arr.toReversed().reverse()
  Object.assign({}, obj)

- 深拷贝：

1. JSON.parse(JSON.stringify(obj))  --- 不能处理，undefined, function, symbol, 不能处理循环引用

2. structuredClone()  --- 不能处理 function, symbol, bigint

3. MessageChannel()  --- 不能处理 function, symbol


- 原理

  深拷贝：递归拷贝，判断是否是引用类型，如果是则递归拷贝，否则直接赋值

# 六、说说你对闭包的理解

- 是什么

  根据作用域链的查找规则，内部函数一定有权力访问外部函数的变量。另外，一个函数执行完后它的执行上下文会被销毁。那么当函数A内部声明一个函数B,而函数B被拿到函数A外部执行时，为了保证以上两个规则正常执行，A函数在执行完毕后会将B需要访问的变量保存在一个集合当中，并留在调用栈当中，这个集合就是闭包。

- 特点：

1. 用于封装模块，避免全局变量污染
2. 延长了变量的生命周期

3. 造成内存泄露

- 场景：

1. 柯里化
2. 单例模式

# 七、说说你对 js 中作用域的理解

- 是什么

  在一个区域中，生效了一些变量和函数，这种区域就叫作用域

- 特点
1. 全局作用域
2. 函数作用域
3. 块级作用域

4. 词法作用域 -- 描述的是一个函数所处的作用域

- 作用域链

  js 引擎在查找变量时，会现在当前作用域中查找，找不到就会去外层作用域查找，层层往上，直到全局作用域，这种查找的链状关系就叫作用域链

# 八、说说你对 js 中原型的理解

- 是什么

  在 js 中原型分为两种，一种是函数的原型（显示原型），一种是对象的原型（隐式原型），显示原型指的是函数身上自带的属性 prototype，隐式原型指的是对象上的 __proto__ 属性

- 特点

  对象的 __proto__ 指向创建它的构造函数的 prototype，因为js 引擎在查找属性时，会现在对象上查找，找不到就会去对象 __proto__ 上查找。所以原型存在的意义就是让实例对象可以访问到公共的方法

- 原型链

  js 引擎在查找属性时，会现在对象上查找，找不到就会去对象 __proto__ 上查找， 还找不到就会顺着 __proto__ 往上查找，直到找到 null 为止，这种查找关系就叫原型链

# 九、说说 js 中的继承

- 是什么

  让子类可以访问到父类的属性和方法

- 实现方式
  1. 原型链继承 -- 多个实例共享一个原型对象，相互影响
  2. 构造函数继承  -- 无法继承到父类原型上的属性
  3. 组合继承  -- 父类构造函数会执行两次，浪费性能

  4. 原型式继承 -- 多个实例共享一个原型对象，相互影响
  5. 寄生式继承  -- 同上
  6. 寄生组合式继承  -- 最优解

  7. 类继承 -- 利用 extends 关键字实现继承

# 十、说说你对 js 中 this 的理解

- 是什么

  this 是 js 中的一个关键字，它可以简化上下文的参数传递，提高代码复用性，它的指向是由函数调用的方式决定的

- 规则：

1. 函数独立调用 --- 默认绑定规则 --- this 指向 window
2. 函数被对象调用 --- 隐式绑定规则 --- this 指向该对象
3. call, apply, bind  --- 显示绑定规则 --- this 指向绑定的对象
4. 函数被 new 调用 --- 构造函数绑定规则 --- this 指向新创建的对象