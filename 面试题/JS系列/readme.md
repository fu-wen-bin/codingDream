# 一、JS数组上常用的的方法有哪些？

* 增：`push()`, `unshift()`, `concat()`, `splice()`
* 删：`shift()`, `pop()`, `slice()`, `splice()`
* 改：`splice()`
* 查：`includes()`, `indexOf()`, `find()`, `findIndex()`, `lastIndexOf()`, `findLastIndex()`
* 遍历：`forEach()`, `map()`, `filter()`, `every()`, `some()`, `sort()`, `reduce()`

# 二、如何实现数组扁平化？flat方法？

- 是什么

flat是Array原型上的函数，用于将高维数组处理成低维数组

- 原理

1. 递归
2. reduce + 递归
3. while + 解构
4. toString()

# 三、字符串上常用的方法有哪些？

- 增：`concat()`
- 删：`slice()`, `substring()`, `substr()`
- 改：`replace()`, `toUpperCase()`, `toLowerCase()`, `trim()`,
  `trimStart()`, `trimEnd()`, `repeat()`, `padEnd()`, `padStart()`
- 查：`includes()`, `indexOf()`, `lastIndexOf()`, `charAt()`, `startWith()`, `endWith()`, `match()`

# 四、谈谈js 中的类型转换机制

- 是什么

js 引擎在执行各种运算符对于数据的类型是有要求的，如何数据类型和预期的不符合，就会发生类型转换

- 特点：

1. 显示类型转换
2. 隐式类型转化

- 显示类型转换：

> 人为借助构造函数来将一种类型转换成希望的类型，这其中如果是原始值转原始值，官方给出了直接的转换结果。
> 但如果是引用类型转原始类型：Number([1, 2])

1. ToNumber([1, 2])  || ToString()
2. ToPrimitive([1, 2], Number)
3. 判断 参数 是否为原始类型，是则返回
4. 否则，调用 xxx.valueOf()，得到原始值则返回
5. 否则，调用 xxx.toString()，得到原始值则返回
6. 否则报错

   <!-- String([1, 2]) -->

- 隐式类型转化:

> 通常发生在 四则运算（+ - * / %），比较运算（== != > < ）判断语句（if while）

# 五、介绍一下 js 中的拷贝问题

- 是什么

因为js 中的原始类型存在栈中，引用类型存在堆中，再把引用地址存在栈中。所以拷贝通常只发生在引用类型上。效果是创建一份新的数据，让新数据拥有原数据一样的属性值

- 方法

1. 浅拷贝：拷贝对象的属性，值如果是引用类型，则共用同一个地址
2. 深拷贝：拷贝对象的属性，值如果是引用类型，则创建新的子对象来进行新的拷贝，实现层层拷贝

- 浅拷贝:

  slice(),
  [].concat(arr),
  [...arr], Object.create()
  arr.toReversed().reverse()
  Object.assign({}, obj)

- 深拷贝：

1. JSON.parse(JSON.stringify(obj))  --- 不能处理，undefined, function, symbol, 不能处理循环引用

2. structuredClone()  --- 不能处理 function, symbol, bigint

3. MessageChannel()  --- 不能处理 function, symbol


- 原理

深拷贝：递归拷贝，判断是否是引用类型，如果是则递归拷贝，否则直接赋值

# 六、说说你对闭包的理解

- 是什么

根据作用域链的查找规则，内部函数一定有权力访问外部函数的变量。另外，一个函数执行完后它的执行上下文会被销毁。那么当函数A内部声明一个函数B,而函数B被拿到函数A外部执行时，为了保证以上两个规则正常执行，A函数在执行完毕后会将B需要访问的变量保存在一个集合当中，并留在调用栈当中，这个集合就是闭包。

- 特点：

1. 用于封装模块，避免全局变量污染
2. 延长了变量的生命周期

3. 造成内存泄露

- 场景：

1. 柯里化
2. 单例模式

# 七、说说你对 js 中作用域的理解

- 是什么

在一个区域中，生效了一些变量和函数，这种区域就叫作用域

- 特点

1. 全局作用域
2. 函数作用域
3. 块级作用域
4. 词法作用域 -- 描述的是一个函数所处的作用域

- 作用域链

js 引擎在查找变量时，会现在当前作用域中查找，找不到就会去外层作用域查找，层层往上，直到全局作用域，这种查找的链状关系就叫作用域链

# 八、说说你对 js 中原型的理解

- 是什么

在 js 中原型分为两种，一种是函数的原型（显示原型），一种是对象的原型（隐式原型），显示原型指的是函数身上自带的属性
prototype，隐式原型指的是对象上的 __proto__ 属性

- 特点

对象的 __proto__ 指向创建它的构造函数的 prototype，因为js 引擎在查找属性时，会现在对象上查找，找不到就会去对象 __proto__
上查找。所以原型存在的意义就是让实例对象可以访问到公共的方法

- 原型链

js 引擎在查找属性时，会现在对象上查找，找不到就会去对象 __proto__ 上查找， 还找不到就会顺着 __proto__ 往上查找，直到找到
null 为止，这种查找关系就叫原型链

# 九、说说 js 中的继承

- 是什么

让子类可以访问到父类的属性和方法

- 实现方式

1. 原型链继承 -- 多个实例共享一个原型对象，相互影响
2. 构造函数继承 -- 无法继承到父类原型上的属性
3. 组合继承 -- 父类构造函数会执行两次，浪费性能
4. 原型式继承 -- 多个实例共享一个原型对象，相互影响
5. 寄生式继承 -- 同上
6. 寄生组合式继承 -- 最优解
7. 类继承 -- 利用 extends 关键字实现继承

# 十、说说你对 js 中 this 的理解

- 是什么

this 是 js 中的一个关键字，它可以简化上下文的参数传递，提高代码复用性，它的指向是由函数调用的方式决定的

- 规则：

1. 函数独立调用 --- 默认绑定规则 --- this 指向 window
2. 函数被对象调用 --- 隐式绑定规则 --- this 指向该对象
3. call, apply, bind --- 显示绑定规则 --- this 指向绑定的对象
4. 函数被 new 调用 --- 构造函数绑定规则 --- this 指向新创建的对象

# 十一、说一说 js 中的事件流

- 是什么

js 中的事件流是指事件在 DOM 树中传播的过程，分为三个阶段：捕获阶段、目标阶段、冒泡阶段

- 特点

1. 事件从window开始，向下传播到目标元素（捕获阶段）-- **父到子**
2. 事件在目标处触发（目标阶段)
3. 事件从目标元素向上冒泡到window（冒泡阶段）-- **子到父**
4. **捕获阶段不会触发目标元素的处理事件，只有冒泡会触发**

- 使用场景

1. 事件委托 -- 借助事件冒泡机制

# 十二、js中类型判断有哪些方法？

1. `typeof` -- 用于判断原始类型和函数类型
    - 注意：对于数组、null、对象等引用类型，返回的都是`object`
2. `instanceof` -- 只能用于判断引用类型，通过原型链判断对象是否是某个构造函数的实例
3. `Array.isArray()`
4. `Object.prototype.toString.call(xx)` -- 让`xx`执行对象上的`toString`方法
    - 对象上的`toString`方法可以返回对象的类型字符串，格式为`[object Type]`
    - 数组上的`toString`方法返回的是逗号分隔的字符串，而不是类型字符串
    - 其他类型上的`toString`方法返回的是字符串字面量，如：'123'

# 十三、说说你对 js 中的事件循环的理解

- 是什么

因为js默认为单线程运行，在运行时碰到耗时长的任务会发生阻塞。为了解决这一问题，js设计了一套循环执行同步和异步的机制，这就是事件循环。

- 特点

任务被分成两种任务：

1. 同步任务：在主线程中执行的任务
2. 异步任务：在主线程外执行的任务，执行完后会将回调函数放入消息队列中
    - 微任务：
        - `Promise.then()`
        - `MutationObserver`
        - `process.nextTick()` -- `nodejs` 环境
    - 宏任务:
        - `script`
        - `setTimeout`
        - `setInterval`
        - `I/O, UI` 渲染
        - `postMessage`, `MessageChannel`

3. 事件循环的执行顺序：
    - 主线程`先执行同步任务`
    - 执行完同步任务后，检查微任务队列，`依次执行微任务`
    - 微任务队列清空后，执行宏任务队列中的第一个宏任务
    - 重复以上步骤

# 十四、说说js中的防抖和节流

- 是什么

是一种优化手段，比如搜索框的输入、scroll、click等可能会在短时间内触发多次，非常浪费资源。防抖节流就是为了优化这种情况的

- 特点

1. 防抖

   > 在事件触发后，等待一段时间，如果在这段时间内又触发了事件，则重新计时。
   >
   > 只有在事件触发后的一段时间内没有再次触发事件，才会执行回调函数 -- (类似回城)

2. 节流

   > 一段规定的时间内，如果多次触发事件，只会执行一次回调函数 -- (类似攻速阈值)

- 实现方式 -- **都需要注意this指向以及传入的参数**

1. 防抖：

   将定时器存在闭包中，使全局可以访问同一个定时器。传入需要触发的回调函数和规定的时长。

   每次触发事件时，清除定时器，重新设置定时器。这样可以做到没有再触发事件后，定时器到期执行回调函数。

2. 节流：

   将第一次的时间设置为0，每次触发事件时获得当前的时间并将其与上一次触发事件的时间进行对比。

   如果时间差大于规定的时间，则执行回调函数，并将当前时间设置为上一次触发事件的时间。

# 十五、js中的本地存储有哪些？区别是什么？

1. cookies -- 存储少量数据，随请求发送，存在过期时间
    - 这个空间存放的内容js无法设置和修改，需要后端靠响应代码来存入
    - 大小：4k
    - 过期时间：可以设置过期时间，不设置默认关闭浏览器就过期
    - 工作原理：浏览器会在每次请求时，将 cookies 中的内容添加到请求头中，后端可以通过请求头来获取 cookies 中的内容
    - 跨域：可以设置跨域

   `<!-- https://www.baidu.com/ -->`
   `<!-- https://top.baidu.com/board -->`

2. localStorage

    - 大小：5M
    - 过期时间：不可以设置过期时间，默认永久存在
    - 工作原理：需要 js 手动存取
    - 跨域：不可以跨域

3. sessionStorage
    - 大小：理论上无穷大
    - 过期时间：页面关闭就过期
    - 工作原理：需要 js 手动存取
    - 跨域：不可以跨域

4. indexdb (纯客户端的本地数据库)

    - 大小：理论上无穷大
    - 过期时间：不可以设置过期时间，默认永久存在
    - 工作原理：需要 js 手动存取，支持存二进制
    - 跨域：不可以跨域
    - 适用场景：
        - 存储大量数据
        - 需要离线访问
