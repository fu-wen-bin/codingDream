# 视言二面

## 自我介绍与学习经历 -- [参考](https://juejin.cn/post/7335337310547017768)

### 请简单介绍一下自己，包括学习前端的过程

面试官您好，我叫傅文斌，东华理工大学26届软件工程专业在读学生，想来应聘贵公司的前端工程师岗位
低年级的时候，我跟着学长一起在B站学习、参加比赛，拿过些许的荣誉，奖学金也拿了一些
个人非常喜欢前端，大三系统学习了前端的基础知识、React框架，掌握了前后端分离的开发模式
后期在老师的课题小组中担任前端开发，完成了一些类似个人博客的小项目，进一步提升了自己的技术能力和团队协作能力
目前仍然在开发在线协作编辑器这一个项目，并且后续会持续维护更新，本项目也已经上传到了我的GitHub仓库
仔细读过《你不知道的JavaScript》,并在掘金上写过相关系列文章40余篇，热爱技术分享，未来会持续学习
我非常期待能加入贵公司，我将会全力以赴完成好自己的工作

### 大三前的课程内容（C、Java、网络基础等）

## 项目经验

### 项目是以什么形式开展的？（学校/个人）

随便编一个，说是老师布置的课设或者进了老师的课题组

### 请详细介绍一个项目（日记工具项目）

直接说亮点就好了，不要说什么很浅显的实现功能比如：

- 前端封装了axios、下拉刷新、日记缓存
- 后端使用了JWT做权限验证、封装MySQL连接函数

### 在项目中的最大收获是什么？是否涉及本地部署或工作流调试？

- 项目学到了前后端分离的开发模式、熟悉前后端联调、RESTful API设计
- 在写前端的时候加强了抽离复杂逻辑的能力

## 计算机基础与网络

### 从输入网址到页面渲染的整个过程

1. DNS域名解析：
    1. 浏览器检查DNS高速缓存
    2. 如果高速缓存中没有该url对应的ip地址，则本地DNS服务器将请求发送给根域名服务器
    3. 如果也没有，本地DNS服务器将请求发给顶级域名服务器
    4. 如果也没有，本地DNS服务器将请求发给权威域名服务器
    5. 权威域名服务器将ip地址返回给本地DNS服务器，本地DNS服务器将url和ip的映射关系写进DNS高速缓存
2. 得到ip地址后，浏览器和服务器将通过TCP协议建立连接
    - TCP连接涉及到三次握手和四次挥手 -- 后续自己说明
3. 浏览器和服务器之间使用HTTP请求数据
4. 在服务器返回数据后，浏览器开始渲染页面
    - 解析HTML，构建DOM树
    - 解析CSS，构建CSSOM树
    - 将DOM树和CSSOM树结合，生成渲染树
    - 布局渲染树，计算每个节点的几何信息
    - 绘制页面

### HTTP与HTTPS的区别

- HTTP是超文本传输协议，HTTPS是安全的超文本传输协议
- HTTP使用明文传输数据，HTTPS使用SSL/TLS协议对数据进行加密
    1. 对称加密和非对称加密：
        1. 对称加密：客户端和服务端使用相同的密钥进行加密和解密，速度快但安全性低
        2. 非对称加密：
            1. 服务端设定一个加密方式生成一对公钥和私钥
            2. 客户端将密钥和数据使用服务端的加密方式进行加密
            3. 服务端使用私钥进行解密得到客户端传输的和密钥
            4. 后续就可以使用对称加密进行数据传输了

### TCP与UDP的特点及应用场景

- TCP是面向连接的协议，UDP是无连接的协议
- TCP提供可靠的数据传输，UDP不保证数据的可靠性
- TCP适用于需要高可靠性的数据传输场景，如文件传输、电子邮件等
- UDP适用于对实时性要求高但对可靠性要求不高的场景，如视频直播、在线游戏等

### TCP三次握手和四次挥手的描述

## 数据结构与算法

### 数组与链表的区别及优缺点

- 数组：
    - 优点：支持随机访问，**内存连续**，缓存友好
    - 缺点：**插入和删除操作效率低**，扩容时需要重新分配内存
- 链表：
    - 优点：插入和删除操作效率高，**内存不连续**，灵活性强
    - 缺点：不支持随机访问，**内存开销大**

### 哈希表的原理及哈希冲突的解决方法

- 原理：
    - 哈希表通过哈希函数将键映射到数组的索引位置，从而实现快速的数据存取
- 哈希冲突的解决方法：
    1. 链地址法：在每个数组索引位置存储一个链表，所有映射到同一索引位置的元素都存储在该链表中
    2. 开放地址法：当发生冲突时，寻找数组中的下一个空闲位置存储元素
        - 线性探测：依次检查下一个位置，直到找到空闲位置
        - 二次探测：按照二次方的方式检查位置，减少聚集
        - 再哈希法：使用另一个哈希函数重新计算索引位置，直到找到一个空闲位置

### 排序算法（冒泡排序、快速排序）

- 冒泡排序：
    - 原理：通过多次遍历数组，比较相邻元素并交换位置，将较大的元素逐渐“冒泡”到数组的末端
    - 时间复杂度：O(n^2)
    - 空间复杂度：O(1)
- 快速排序：
    - 原理：选择一个基准元素，将数组分成两部分，一部分小于基准元素，另一部分大于基准元素，然后递归地对这两部分进行排序
    - 时间复杂度：平均O(n log n)，最坏O(n^2)
    - 空间复杂度：O(log n)（递归栈空间）

## 前端技术与优化

### 前端页面渲染优化方法（缓存、懒加载、防抖节流等）

1. html -- 语义化、尽量不要嵌套过深
2. css -- 选择器尽量精准简短、减少重绘回流、使用css3动画代替js动画
3. js -- 注意使用async，defer、防抖节流、懒加载、压缩、webWorker多开线程
4. 渲染优化 -- 减少重绘回流、使用虚拟DOM、避免不必要的渲染

### 跨域问题的解决方法（CORS、JSONP、代理等）

1. **JSONP** -- 利用script、img等标签不受同源策略的影响，通过动态创建script标签来实现跨域请求
    - 前端创建回调函数、指向服务端地址的script标签并将url地址带上回调函数名等路径参数
    - 服务端接收到请求后，将数据传入回调函数并返回给前端
    - 浏览器会自动执行回调函数
    - 缺点：只支持GET请求，存在安全隐患。一定要后端配合，否则无法使用
2. **CORS** -- 服务器在响应头中添加`Access-Control-Allow-Origin`等字段，允许指定的源访问资源
    - 简单请求：GET、POST、HEAD请求，且请求头和Content-Type符合要求
    - 复杂请求：PUT、DELETE等请求，或者自定义请求头、Content-Type不符合要求
        - 浏览器会先发送一个OPTIONS预检请求，询问服务器是否允许该跨域请求
        - 服务器返回允许的源、方法、头等信息
        - 浏览器根据服务器的响应决定是否发送实际请求
3. **代理** -- 前端请求同源的代理服务器，代理服务器再请求目标服务器
    - 通过配置开发环境的代理（如webpack dev server、vite等）
    - 通过Nginx等反向代理服务器

### 虚拟DOM和diff算法的理解

### CSS盒模型的理解

浏览器会将页面元素渲染成一个个矩形盒子，这些盒子由内容、内边距、边框、外边距

- 盒子模型分为标准盒模型和怪异盒模型
    - 标准盒模型：用户定义的宽高只包含内容区域宽高
    - 怪异盒模型：用户定义的宽高包括了内容、内边距、边框

### React与Vue的区别及使用场景

## CSS与JavaScript

### CSS选择器及优先级规则

### JavaScript数据类型及类型判断方法（typeof、instanceof、Object.prototype.toString）

### let与const的区别

### display属性常见值及作用（如none、flex、inline-block）

## HTML5与安全性

### HTML5的新特性（语义标签、本地存储等）

### localStorage与cookies的区别及安全性

## 实习规划与学习计划

### 实习期间的学习计划及未来1~2年的职业目标

### 遇到的困难及如何克服（如算法题学习）

## 公司相关问题

### 工作内容（电商主站、小程序、管理后台、低代码平台）

### 公司地址及租房交通情况（杭州西湖区）