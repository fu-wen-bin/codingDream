# 一、说说你对CSS盒子模型的理解

答：(问题回答逻辑：是什么 -> 特性 -> 场景应用)

- 是什么：

浏览器渲染页面时，会根据一定的标准将**每个HTML元素**渲染成一个包含内容、内边距、边框和外边距的盒子

- 特性：

盒子模型分为两种类型：标准盒子模型（content-box）和 IE(怪异)盒子模型（border-box）。

在标准盒子模型中，css设置的宽度和高度只包括内容区域，而在IE(怪异)盒子模型中，css设置的宽度和高度包括内容、内边距和边框。

内容是盒子的实际内容区域，内边距是内容与边框之间的空间，边框是包围内容和内边距的线条，外边距是盒子与其他元素之间的空间。

通过调整这些部分的大小和属性，可以控制元素在页面上的布局和外观。

比较形象的理解是打开浏览器的检查，计算样式板块展示的就是选中元素的盒子模型。

# 二、CSS选择器有哪些？优先级？

1. CSS选择器类型(按优先级排序)

    - ID选择器：选择具有指定ID的元素，如 `#idName`

    - 属性选择器：选择具有指定属性的元素，如 `[type="text"]`
    - 类选择器：选择所有指定类名的元素，如 `.className`
    - 伪类选择器：选择特定状态的元素，如 `:hover`, `:focus`

    - 元素选择器：选择所有指定类型的元素，如 `div`, `p`, `span`
    - 伪元素选择器：选择元素的特定部分，如 `::before`, `::after`

    - 通配符选择器：选择所有元素，如 `*`

    - 子代选择器：选择指定元素的直接子元素，如 `div > p`
    - 后代选择器：选择指定元素的所有后代元素，如 `div p`
    - 相邻兄弟选择器：选择紧接在指定元素后的兄弟元素，如 `h1 + p`
    - 通用兄弟选择器：选择指定元素后的所有兄弟元素，如 `h1 ~ p`

2. 样式权重计算方法
    - 计算元素的样式时，浏览器会根据选择器的特异性（权重）来决定使用哪个样式。
    - 特异性计算规则：
        - 内联样式 (`style="..."`) ：(1, 0, 0, 0)
        - ID选择器 (`#id`) ：(0, 1, 0, 0)
        - 类选择器、属性选择器和伪类选择器 (`.class`、`[type="text"]`) ：(0, 0, 1, 0)
        - 元素选择器和伪元素选择器 (`div, p`) ：(0, 0, 0, 1)
        - 通配符选择器(`*`)：(0, 0, 0, 0)
        - 子代选择器和后代选择器的特异性与其父元素的特异性相加

> 准确的计算公式：(内联，ID，类，元素) = (0, 0, 0, 0)
>
> 有n个则将0变为n，其他不变。浏览器从左往右对比，同一级相同再往下

例如：

- `div #header .nav a` 的特异性为 `(ID) + (类) + (元素)*2 = (1, 1, 2)`

- `#header .nav a` 的特异性为 `(ID) + (类) + (元素) = (1, 1, 1)`

- 因此，`div #header .nav a` 的样式会覆盖 `#header .nav a` 的样式。

# 三、说说 em/px/rem/vw/vh/vmin/vmax 单位的区别

- 是什么：

1. 相对单位：

    - **em**：相对于父元素的字体大小。1em 等于当前元素的字体大小。例如，如果父元素的字体大小是16px，则1em等于16px。

    - **rem**：相对于根元素（通常是html）的字体大小。1rem 等于根元素的字体大小。例如，如果html的字体大小是16px，则1rem等于16px。

    - **vw**：视口宽度的百分比单位。1vw 等于视口宽度的1%。例如，如果视口宽度是1000px，则1vw等于10px。

    - **vh**：视口高度的百分比单位。1vh 等于视口高度的1%。例如，如果视口高度是800px，则1vh等于8px。

2. 绝对单位：

    - **px**：像素单位，表示屏幕上的一个点。它是一个**绝对单位**，通常用于精确控制元素的大小。

- 特性：

1. **em**：相对于父元素的字体大小。1em 等于当前元素的字体大小。例如，如果父元素的字体大小是16px，则1em等于16px。

2. **rem**：相对于根元素（通常是html）的字体大小。1rem 等于根元素的字体大小。例如，如果html的字体大小是16px，则1rem等于16px。

3. **vw**：视口宽度的百分比单位。1vw 等于视口宽度的1%。例如，如果视口宽度是1000px，则1vw等于10px。

4. **vh**：视口高度的百分比单位。1vh 等于视口高度的1%。例如，如果视口高度是800px，则1vh等于8px。

- 场景应用：

做响应式布局和移动端布局适配时，使用相对单位。做精确布局时，使用绝对单位。

# 四、CSS中有哪些隐藏元素的方法？区别是什么？

1. `display:none`：元素不占据文档流，不响应事件
2. `visibility:hidden`：元素占据文档流，但不可见，也不响应事件
3. `opacity:0`：元素透明度为0，占据文档流，可以响应事件
4. `position:absolute`：元素脱离文档流，位置相对于最近的定位祖先元素，仍然响应事件
5. `width:0;height:0`：元素宽高为0，不占据文档流，不可见，不可响应事件
6. `clip-path: polygon(0 0, 0 0, 0 0, 0 0)`：占据文档流，但内容不可见，不响应事件

# 五、说说你对BFC的理解？

- 是什么：

块级格式化上下文（BFC）是一个独立的渲染区域，内部有一套属于它自己的渲染规则

- 特性：

1. 和普通容器一样，BFC容器中的元素依然是垂直排列的
2. 同普通容器一样，BFC**容器内的元素在垂直方向上同样存在**`margin`重叠
3. `BFC`容器**内的元素不会与外部元素**发生`margin`塌陷
4. BFC容器在计算高度时，会将浮动元素的高度计算在内

创建BFC的方式有：

1. `overflow: hidden || auto || scroll || overlay` -- 不为 visible
2. `position: absolute || fixed`
3. `display: inline-xxx || flex || grid || table-xxx`
4. `float: left || right` -- 不为none

- 场景应用：

1. 清除浮动
2. 防止`margin`塌陷

# 六、元素水平垂直居中的方法有哪些？

1. 使用 `flexbox`布局：
2. 使用 定位 + `margin: 负自身宽度的一半`  --> 优化：定位 + `transform: translate(-50%, -50%)`
3. 使用 grid布局
4. 使用 table布局

# 七、实现多栏布局

1. 两栏布局

    - 弹性
    - calc() 计算右侧宽度
    - 浮动
    - 三栏布局

    - 弹性 + order （主体内容优先加载）

2. grid 布局

3. 圣杯布局 (浮动 + 定位 + 负 margin)

4. 双飞翼布局 (浮动 + 负 margin)

# 八、CSS中有哪些动画？如何实现？

1. 过渡动画   （Transition）
2. 转变动画   （Transform）
3. 自定义动画 （animation）

# 九、解释一下回流重绘

- 从输入url 到页面渲染完整过程
1. 网络层
2. 浏览器层

- 浏览器层（得到数据包之后）：
1. 解析 `html` 数据得到 `DOM` 树
2. 解析 `css` 数据得到 `CSSOM` 树
3. 合并 `DOM` 树和 `CSSOM` 树得到 渲染树
4. 计算页面布局 （得到可见的每一个容器的几何属性）（回流）
5. 将信息发给 GPU，GPU 会根据信息绘制页面（重绘）

- 发生回流的操作：
   1. 刷新浏览器页面
   2. 容器的几何属性变更
   3. 增加或者删除 可见的 `DOM` 元素
   4. 浏览器窗口尺寸变更


-  ```
   DOM: {
     tag: 'div',
     style: {
       width: '100px',
       height: '100px',
       background: 'red'
     }
     attr: {
       id: 'app',
       class: 'container'
     },
     children: [
       {
         tag: 'div',
         style: {
           width: '100px',
           height: '100px',
           background: 'red'
         }
         attr: {
           id: 'title',
           class: 'title'
         },
         children: [
           {
             text: 'hello world'
           }
         ]
       }
     ]
   }
   ```
   
   <!-- div p span{
     xxxxxx
   } -->
-  CSSOM:{
   selector: 'div',
   style: {
   width: '100px',
   height: '100px',
   background: 'red'
   }
   }

- 浏览器的优化策略：
  由于每一次回流重绘都会带来额外的性能消耗，因此大多数浏览器会通过队列来优化回流重绘的次数，浏览器将会导致回流的操作都存入队列，直到一段时间之后或者达到阈值，才一次性清空队列。

- 特殊的属性：
  offsetWidth, offsetHeight, offsetTop, offsetLeft
  scrollWidth, scrollHeight, scrollTop, scrollLeft
  clientWidth, clientHeight, clientTop, clientLeft
  以上这些属性会强制刷新优化队列

- 如何尽量减少回流重绘
1. 将要发生回流操作的 dom 先从文档流中剔除，待所有的操作完毕后再添加回文档流
2. 使用文档碎片
3. 使用克隆节点


# 十、CSS画一个三角形
1. 裁剪
2. 边框

# 十一、聊一聊响应式布局
- 是什么
  页面上的容器根据屏幕尺寸的变换而自适应的调整布局位置和大小

- 实现方式：
1. 媒体查询
2. 百分比
3. vw/vh
4. rem + 媒体查询 || js


# 十二、画一条 0.5px 的线
1. transform: scaleY(0.5);

# 十三、让浏览器支持小于 12px 的文字的方式
1. 新版本已经适配
2. 老版本 zoom：xx;  （变焦）

# 十四、聊一聊css 的预编译语言 （预处理器）
- 是什么
  扩充了css 语法，增加了变量、函数、混合、继承等功能，让css 更好维护书写更高效。

- 有哪些
1. sass
2. less
3. stylus  -- 基于nodejs 运行的一种css 预编译语言