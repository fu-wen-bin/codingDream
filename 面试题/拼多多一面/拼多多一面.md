# 请介绍你的学习经历与学习方法

# 请谈谈你在AI相关领域的兴趣与实践经历

# 你在移动端项目中采用了怎样的适配方案？

- 采用REM适配方案
- 在html根元素上设置font-size，通常设置为视口宽度的十分之一（即1rem = 10vw）
- 使用媒体查询来限制最大和最小的font-size，确保在极端屏幕尺寸下也能有良好的显示效果
- 在CSS中使用rem作为单位来定义元素的尺寸和间距

# 低代码平台项目的开发框架是什么？核心实现思路是怎样的？

- 维护一份完整的JSON对象，用JSON来描述页面结构，组件嵌套关系，以及组件上的各种属性值
- 通过递归调用React.createElement，将JSON对象转换为React元素，最终渲染出页面
- Zustand来管理全局状态，一个仓库管理JSON数据、另一个管理存放的组件信息
- 对每个组件进行自定义配置，包括样式、属性、事件等

# 你了解哪些登录鉴权方案？在项目中具体采用了哪种方案及实现逻辑？

1. 基于Token的鉴权方案 -- 分摊服务器压力
    - 使用JWT（JSON Web Token）
2. 基于Cookie的鉴权方案
    - 后端直接在登陆成功的响应头中设置一个cookie，前端的请求会自动携带cookie
3. 基于Session的鉴权方案 -- 服务器压力大，但是非常安全
    - 后端在用户登录成功后创建一个session，并将session id存储在cookie中
    - 前端请求会自动携带cookie，后端通过session id来验证用户身份

# 你对Zustand状态管理库的使用情况如何？是否了解其shallow方法？

- shallow方法用于浅比较两个对象的属性值是否相等，常用于优化组件渲染性能，避免不必要的重新渲染 #

# 在项目中是如何进行请求拦截与错误处理的？对于多接口并发错误跳转问题有哪些解决思路？

# 请阐述REM适配的实现方式

# 如何实现自定义Hook（usePrevious）？

# 你对服务端渲染（SSR）的概念有何了解？是否有实际使用经验？

# 你了解Polyfill的具体内容吗？

# 节流与防抖的区别是什么？各自的使用场景有哪些？

    - 防抖是在一定时间段内没有再次触发事件，才会执行回调函数 -- (类似回城)
        - 防抖普遍用在**调整浏览器窗口大小、多次点击按钮发送请求、文本编辑器实时保存**等场景
    - 节流是一定时间段内，如果多次触发事件，只会执行一次回调函数 -- (类似攻速阈值)
        - 节流普遍用在**窗口缩放，浏览器播放事件，每个一秒计算一次进度信息**等场景

# 组件曝光打点是如何实现的？是否重新打点由什么决定？

    - 组件曝光打点通常通过监听滚动事件或使用Intersection Observer
      API来检测组件是否进入视口，从而触发打点逻辑。重新打点的决定因素通常包括用户行为（如滚动、点击等）和组件状态变化（如重新渲染、数据更新等）。

# 你对Promise的finally方法了解多少？

# Diff算法的核心思路是什么？

# 如何实现删除列表项的DOM操作？若事件绑在ul上又该如何处理？