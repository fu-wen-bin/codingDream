# 请介绍你的学习经历与学习方法

# 请谈谈你在AI相关领域的兴趣与实践经历

# 你在移动端项目中采用了怎样的适配方案？

- 采用REM适配方案
- 在html根元素上设置font-size，通常设置为视口宽度的十分之一（即1rem = 10vw）
- 使用媒体查询来限制最大和最小的font-size，确保在极端屏幕尺寸下也能有良好的显示效果
- 在CSS中使用rem作为单位来定义元素的尺寸和间距

# 低代码平台项目的开发框架是什么？核心实现思路是怎样的？

- 维护一份完整的JSON对象，用JSON来描述页面结构，组件嵌套关系，以及组件上的各种属性值
- 通过递归调用React.createElement，将JSON对象转换为React元素，最终渲染出页面
- Zustand来管理全局状态，一个仓库管理JSON数据、另一个管理存放的组件信息
- 对每个组件进行自定义配置，包括样式、属性、事件等

# 你了解哪些登录鉴权方案？在项目中具体采用了哪种方案及实现逻辑？

1. 基于Token的鉴权方案 -- 分摊服务器压力
    - 使用JWT（JSON Web Token）
2. 基于Cookie的鉴权方案
    - 后端直接在登陆成功的响应头中设置一个cookie，前端的请求会自动携带cookie
3. 基于Session的鉴权方案 -- 服务器压力大，但是非常安全
    - 后端在用户登录成功后创建一个session，并将session id存储在cookie中
    - 前端请求会自动携带cookie，后端通过session id来验证用户身份

# 你对Zustand状态管理库的使用情况如何？是否了解其shallow方法？

- Zustand创建一个useXXXStore钩子函数，该函数返回仓库中的数据
- 将useXXXStore调用到组件中，即可获取仓库中的数据，并收集依赖(记录哪个组件用到了仓库中的数据)
- 通过useEffect监听仓库中数据的变化，当数据变化时，触发依赖收集中对应组件重新渲染

- shallow方法用于浅比较两个对象的属性值是否相等，常用于优化组件渲染性能，避免不必要的重新渲染 #

# 在项目中是如何进行请求拦截与错误处理的？对于多接口并发错误跳转问题有哪些解决思路？

- 使用axios的请求拦截器，在请求发送前统一添加token等公共参数
- 使用响应拦截器，统一处理响应数据和错误。主要是针对401未授权错误，进行统一的跳转登录处理
- 对于多接口并发错误跳转问题，可以使用Promise.all，一个请求失败则失败，避免多次跳转

# 请阐述REM适配的实现方式

# 如何实现自定义Hook（usePrevious）？

- usePrevious用于获取组件上一次渲染时的某个值
- 使用useRef来创建一个ref对象，用于存储上一次的值
- 在useEffect中更新ref对象的current属性为当前值
- 利用useEffect为异步的特性，直接返回ref对象的current属性，即为上一次的值

# 你对服务端渲染（SSR）的概念有何了解？是否有实际使用经验？

- SSR(Server Side Rendering)是指在**服务器端将React组件渲染成HTML字符串**，并将其发送到客户端
- 假设项目中有100个页面，在前端项目中启动一个node中间层，负责将项目的第一个直接输出给浏览器，剩余的99个页面通过前端项目进行渲染

# 你了解Polyfill的具体内容吗？

# 节流与防抖的区别是什么？各自的使用场景有哪些？

    - 防抖是在一定时间段内没有再次触发事件，才会执行回调函数 -- (类似回城)
        - 防抖普遍用在**调整浏览器窗口大小、多次点击按钮发送请求、文本编辑器实时保存**等场景
    - 节流是一定时间段内，如果多次触发事件，只会执行一次回调函数 -- (类似攻速阈值)
        - 节流普遍用在**窗口缩放，浏览器播放事件，每个一秒计算一次进度信息**等场景

# 组件曝光打点是如何实现的？是否重新打点由什么决定？

    - 组件曝光打点通常通过监听滚动事件或使用Intersection Observer
      API来检测组件是否进入视口，从而触发打点逻辑。重新打点的决定因素通常包括用户行为（如滚动、点击等）和组件状态变化（如重新渲染、数据更新等）。

# 你对Promise的finally方法了解多少？

# Diff算法的核心思路是什么？

# 如何实现删除列表项的DOM操作？若事件绑在ul上又该如何处理？